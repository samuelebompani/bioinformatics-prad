# Install and load packages

First of all, we need to install all the packages needed for this lesson (it will take a while):

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("curatedTCGAData");
BiocManager::install("TCGAutils");
# BiocManager::install("BioinformaticsFMRP/TCGAbiolinks")
BiocManager::install("TCGAbiolinks")
BiocManager::install("NetPreProc");
BiocManager::install("NEMO"); # [GROUP]

install.packages("SNFtool");
install.packages("caret");
install.packages("cluster");
install.packages("mclustcomp");
install.packages("factoextra");
```

Now we can load the packages:

```{r}
library("curatedTCGAData");
library("TCGAbiolinks");
library("TCGAutils");
library("NetPreProc");
library("SNFtool");
library("caret");
library("cluster"); #pam
library("mclustcomp");
library("NEMO");
library("factoextra");
```

# Multi-omics data (1)

Download the dataset:

```{r}
assays <- c("miRNASeqGene", "RNASeq2Gene", "RPPAArray");
mo <- curatedTCGAData(diseaseCode = "PRAD", 
                        assays = assays, 
                        version = "2.0.1", dry.run = FALSE);

mo <- mo[, , paste0("PRAD", "_", assays, "-20160128")];
mo;
```

# Filtering (2)

```{r warning=FALSE}
primary <- TCGAutils::TCGAsampleSelect(colnames(mo), c("01"));
mo <- mo[, primary, ];

# Check for replicates (anyReplicated checks the so called biological or 
# primary unit in the sampleMap of the MultiAssayExperiment object, that
# corresponds to the first 12 characters of the barcodes for TCGA data):
check_rep <- anyReplicated(mo);
print(check_rep);

```

```{r}
# The information regarding if the sample is FFPE is stored in the clinical data,
# which are accessible using colData(). 
no_ffpe <- which(as.data.frame(colData(mo))$patient.samples.sample.is_ffpe == "no");
mo <- mo[, no_ffpe, ];

# Obtain samples having all the considered omics:
complete <- intersectColumns(mo);

# Extract assays in list:
complete <- assays(complete);

# Obtain matrices samples x features:
complete <- lapply(complete, FUN=t)

```

```{r}
# Remove features having NAs (present only in proteomics data):
complete[[3]] <- complete[[3]][, colSums(is.na(complete[[3]])) == 0];

# Remove features with near zero variance and retain top 100 features 
# having higher variance:
nf <- 100;
for(i in 1:length(complete)){
    
    idx <- caret::nearZeroVar(complete[[i]])
    message(paste("Removed ", length(idx), "features from", names(complete)[i]));
    if(length(idx) != 0){
        complete[[i]] <- complete[[i]][, -idx];
    }

    if(ncol(complete[[i]]) <= nf) next
    
    vars <- apply(complete[[i]], 2, var);
    idx <- sort(vars, index.return=TRUE, decreasing = TRUE)$ix;
    
    complete[[i]] <- complete[[i]][, idx[1:nf]];
    
}

# Perform features standardization using z-score:
zscore <- function(data){
    
    zscore_vec <- function(x) { return ((x - mean(x)) / sd(x))}
    data <- apply(data, 2, zscore_vec)
    
    
    return(data)
}

complete <- lapply(complete, zscore);

# Clean barcodes retaining only "Project-TSS-Participant":
for(v in 1:length(complete)){
    rownames(complete[[v]]) <- substr(rownames(complete[[v]]), 1, 12);
}
```

# Download the desease subtypes (3 - 4)

```{r}
# Download disease subtypes from TCGAbiolinks:
subtypes <- as.data.frame(TCGAbiolinks::PanCancerAtlas_subtypes());
subtypes <- subtypes[subtypes$cancer.type == "PRAD", ];

# Remove all the rows with a Nan value in the Subtype_Integrative column
subtypes <- subtypes[!is.na(subtypes$Subtype_Integrative),];

# Retain only primary solid tumors and select samples in common with omics data
# (in the same order):
subtypes <- subtypes[TCGAutils::TCGAsampleSelect(subtypes$pan.samplesID, "01"), ];
sub_select <- substr(subtypes$pan.samplesID,1,12) %in% rownames(complete[[1]]);
subtypes <- subtypes[sub_select, ];
rownames(subtypes) <- substr(subtypes$pan.samplesID, 1, 12);
subtypes <- subtypes[rownames(complete[[1]]),];

# Print number of samples for each subtype:
table(subtypes$Subtype_Integrative)
```

# Similarity Network Fusion (5)

```{r}
# Compute similarity matrix for each data source using the scaled
# exponential euclidean distance:
W_list <- list();
for(i in 1:length(complete)){
    Dist <- (dist2(as.matrix(complete[[i]]), as.matrix(complete[[i]])))^(1/2);
    W_list[[i]] <- affinityMatrix(Dist);
}
    
# Integration of multi-omics data using Similarity Network Fusion:
# t is the number of iterations and K is the number of neighbours to 
# consider to compute the local similarity matrix:
M_snf <- SNF(W_list, K=20, t=20)
```

# Mean Fusion (6)

```{r}
# Do not use 'complete', but 'W_list' because the former is the raw data,
# the latter are the similarity (square) matrices.
M_mean <- Reduce("+", W_list) / length(W_list)
```

# NEMO (7)

```{r}
M_nemo <- nemo.affinity.graph(W_list, k=20)
# M_nemo_2 <- nemo.clustering(complete, num.neighbors=20)
```

# PAM (8)

```{r}
k <- length(unique(na.omit(subtypes$Subtype_Integrative)));
clusterings = list();

# a
for (i in 1:3) {
	dist <- 1 - NetPreProc::Prob.norm(W_list[[i]]);
	res <- pam(dist, k=k, diss=TRUE);
	clusterings <- append(clusterings, list(res));
}

# b
dist <- 1 - NetPreProc::Prob.norm(M_mean);
res <- pam(dist, k=k, diss=TRUE);
clusterings <- append(clusterings, list(res));

# c
# 'diss' should be FALSE because SNF computes a similarity matrix,
# not a dissimilarity (aka distance) matrix. BUT if we don't put
# diss=TRUE then the number of medoids is huge...???
res <- pam(M_snf, k=k, diss=TRUE);
clusterings <- append(clusterings, list(res));

# d
dist <- 1 - NetPreProc::Prob.norm(M_nemo);
res <- pam(dist, k=k, diss=TRUE);
clusterings <- append(clusterings, list(res))
```

```{r}
print("1")
print(clusterings[[1]]$medoids)
print("2")
print(clusterings[[2]]$medoids)
print("3")
print(clusterings[[3]]$medoids)

print("4")
print(clusterings[[4]]$medoids)
print("5")
print(clusterings[[5]]$medoids)
print("6")
print(clusterings[[6]]$medoids)
```

# NEMO clustering (9)

```{r}
M_nemo_clustering <- nemo.clustering(W_list)
```

# Spectral clustering (10)

```{r}
M_spectral <- SNFtool::spectralClustering(M_snf, K=k)
```

# Graphs (11)

```{r}
# Covert disease subtypes to numeric vector:
labels <- as.numeric(factor(subtypes$Subtype_Integrative, levels=unique(subtypes$Subtype_Integrative)));

# Compute measures:
types <- c("rand", "adjrand", "nmi1");
for (clustering in clusterings) {
	metrics.pam <- mclustcomp(clustering$clustering, labels, types=types);
	print(as.data.frame(metrics.pam))
}
```

1.  Un barplot per ogni clustering in cui per ogni subtype indichiamo quante persone sono in quel subtype, comparando con i risultati di iCluster.
2.  Tabelle tabelle tabelle
3.  Cluster plot mappando su 2 dimensioni (t-SNE???????)

```{r}
par(mfrow = c(2, 3))

for (clustering in clusterings) {
	barplot(table(clustering$clustering),
		col = c("#5D2A42", "#FB6376", "#FCB1A6"),
		main = "AAAA")
}
```
