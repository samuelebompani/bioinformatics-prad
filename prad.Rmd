---
title: "Bioinformatics project (2022-2023)"
author: "Samuele Bompani, Luigi Foscari"
date: "May 2023"
output:
  html_notebook:
    toc: yes
    number_sections: yes
    toc_float: yes
    theme: cerulean
    fig_caption: yes
editor_options: 
  markdown: 
    wrap: 72
---
Prostate cancer is the second most common cancer in men worldwide. Its incidence is influenced by age, family history, genetic factors, and race. Localized prostate cancer can vary in behavior, ranging from aggressive to indolent forms. Risk stratification systems have been developed to predict progression and guide treatment decisions based on clinical and pathological factors. Molecular features play a crucial role in improving risk stratification and treatment approaches.

Advancements in technology have enabled the analysis of multiple omics data types, which are valuable for understanding diseases and personalized medicine. Integrative analysis of these data types can provide holistic insights and help classify cancer subtypes. While current subtyping methods are typically based on a single omic, the integration of multiple data types is necessary to enhance accuracy.

There are three main approaches to multi-omics clustering: early, middle and late integration. Early integration combines all omic data into one matrix and applies single-omic clustering, but it overlooks the different distributions of values across omics. Middle integration builds a single model that considers all omics, incorporating joint dimension reduction and similarity-based analyses. Feature selection is essential due to the high dimensionality and complexity of the data, but similarity-based methods offer improved runtime and reduced reliance on feature selection. Late integration clusters each omic separately and then integrates the results, ignoring consistent interactions across omics. 

Traditional approaches to multi-omics analysis have limitations. NEMO constructs inter-patient similarity matrices for each omic, integrates them into one network, and performs clustering based on the integrated network. This approach is computationally efficient and does not require iterative optimization.

Despite progress, there is still much to uncover about the molecular basis of prostate cancer and its implications for risk stratification. Further research, using integrative multi-omics analysis and exploring novel clustering methods, such as NEMO or PVC, can enhance our understanding of prostate cancer and lead to more effective risk assessment and treatment strategies.


# Install and load packages

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(
  c("curatedTCGAData",
    "TCGAutils",
    "TCGAbiolinks",
    "NetPreProc",
    "remotes",
    "Shamir-Lab/NEMO/NEMO",
    "SNFtool",
    "caret",
    "cluster",
    "mclustcomp"),
  ask = FALSE
);
```
```{r}
library("curatedTCGAData");
library("TCGAbiolinks");
library("TCGAutils");
library("NetPreProc");
library("SNFtool");
library("caret");
library("cluster"); #pam
library("mclustcomp");
library("NEMO");
```

# Multi-omics data (1)

```{r}
assays <- c("miRNASeqGene", "RNASeq2Gene", "RPPAArray");
mo <- curatedTCGAData(diseaseCode = "PRAD", 
                      assays = assays, 
                      version = "2.0.1",
                      dry.run = FALSE,
                      verbose = FALSE);

mo <- mo[, , paste0("PRAD", "_", assays, "-20160128")];
mo;
```

# Filtering (2)

```{r warning=FALSE}
primary <- TCGAutils::TCGAsampleSelect(colnames(mo), c("01"));
mo <- mo[, primary, ];

# Check for replicates (anyReplicated checks the so called biological or 
# primary unit in the sampleMap of the MultiAssayExperiment object, that
# corresponds to the first 12 characters of the barcodes for TCGA data):
check_rep <- anyReplicated(mo);
print(check_rep);

```

```{r}
# The information regarding if the sample is FFPE is stored in the clinical data,
# which are accessible using colData(). 
no_ffpe <- which(as.data.frame(colData(mo))$patient.samples.sample.is_ffpe == "no");
mo <- mo[, no_ffpe, ];

# Obtain samples having all the considered omics:
complete <- intersectColumns(mo);

# Extract assays in list:
complete <- assays(complete);

# Obtain matrices samples x features:
complete <- lapply(complete, FUN=t)

```

```{r}
# Remove features having NAs (present only in proteomics data):
complete[[3]] <- complete[[3]][, colSums(is.na(complete[[3]])) == 0];

# Remove features with near zero variance and retain top 100 features 
# having higher variance:
nf <- 100;
for(i in 1:length(complete)){
    
    idx <- caret::nearZeroVar(complete[[i]])
    message(paste("Removed ", length(idx), "features from", names(complete)[i]));
    if(length(idx) != 0){
        complete[[i]] <- complete[[i]][, -idx];
    }

    if(ncol(complete[[i]]) <= nf) next
    
    vars <- apply(complete[[i]], 2, var);
    idx <- sort(vars, index.return=TRUE, decreasing = TRUE)$ix;
    
    complete[[i]] <- complete[[i]][, idx[1:nf]];
    
}

# Perform features standardization using z-score:
zscore <- function(data){
    
    zscore_vec <- function(x) { return ((x - mean(x)) / sd(x))}
    data <- apply(data, 2, zscore_vec)
    
    
    return(data)
}

complete <- lapply(complete, zscore);

# Clean barcodes retaining only "Project-TSS-Participant":
for(v in 1:length(complete)){
    rownames(complete[[v]]) <- substr(rownames(complete[[v]]), 1, 12);
}
```

# Download the desease subtypes (3 - 4)

```{r}
# Download disease subtypes from TCGAbiolinks:
subtypes <- as.data.frame(TCGAbiolinks::PanCancerAtlas_subtypes());
subtypes <- subtypes[subtypes$cancer.type == "PRAD", ];

# Remove all the rows with a Nan value in the Subtype_Integrative column
na_subtypes = is.na(subtypes$Subtype_Integrative)
subtypes <- subtypes[!na_subtypes,];

# Keep only the patients from 'subtypes' in 'complete', but in the same order
sub_select <- substr(subtypes$pan.samplesID, 1, 12) %in% rownames(complete[[1]]);
subtypes <- subtypes[sub_select, ];

# Retain from the samples only the ones with a valid subtype
subtype_filter <- substr(subtypes$pan.samplesID, 1, 12);
for (i in 1:length(complete))
  complete[[i]] <- subset(complete[[i]], rownames(complete[[i]]) %in% subtype_filter)

# TODO: CHECK THAT complete[[i]] IS IN THE SAME ORDER AS subtype
for (i in 1:length(complete))
  complete[[i]] <- complete[[i]][, rownames(subtypes)]

# Print number of samples for each subtype:
table(subtypes$Subtype_Integrative)
```

```{r}
# Compute similarity matrix for each data source using the scaled
# exponential euclidean distance:
W_list <- list();
for(i in 1:length(complete)) {
    Dist <- (dist2(as.matrix(complete[[i]]), as.matrix(complete[[i]])))^(1/2);
    W_list[[i]] <- affinityMatrix(Dist);
}
```

# Similarity Network Fusion (5)

```{r}
# Integration of multi-omics data using Similarity Network Fusion:
M_snf <- SNF(W_list, K=20, t=20)
```

# Mean Fusion (6)

```{r}
# Integration of multi-omics data using the average
M_mean <- Reduce("+", W_list) / length(W_list)
```

# NEMO (7)

```{r}
# Integration of multi-omics data using NEMO
M_nemo <- nemo.affinity.graph(W_list, k=20)
```

# PAM (8)

```{r}
k <- length(unique(na.omit(subtypes$Subtype_Integrative)));
clusterings = list();

# OMIC (a)
for (i in 1:3) {
	dist <- 1 - NetPreProc::Prob.norm(W_list[[i]]);
	D <- as.dist(dist);
	clusterings[assays[[i]]] <- list(pam(D, k=k));
}

# MEAN (b)
dist <- 1 - NetPreProc::Prob.norm(M_mean);
D <- as.dist(dist);
clusterings$mean <- pam(D, k=k);

# SNF (c)
D <- as.dist(M_snf);
clusterings$snf <- pam(D, k=k);

# NEMO (d)
dist <- 1 - NetPreProc::Prob.norm(M_nemo);
D <- as.dist(dist);
clusterings$nemo <- pam(D, k=k)
```

```{r}
print(clusterings$miRNASeqGene$medoids)
print(clusterings$RNASeq2Gene$medoids)
print(clusterings$RPPAArray$medoids)

print(clusterings$mean$medoids)
print(clusterings$snf$medoids)
print(clusterings$nemo$medoids)
```

# NEMO clustering (9)

```{r}
M_nemo_clustering <- nemo.clustering(W_list)
```

# Spectral clustering (10)

```{r}
M_spectral <- SNFtool::spectralClustering(M_snf, K=k)
```

# Graphs (11)

```{r}
# Covert disease subtypes to numeric vector:
labels <- as.numeric(factor(subtypes$Subtype_Integrative, levels=unique(subtypes$Subtype_Integrative)));

# Compute measures:
types <- c("rand", "adjrand", "nmi1");
for (clustering in clusterings) {
	metrics.pam <- mclustcomp(clustering$clustering, labels, types=types);
	print(as.data.frame(metrics.pam))
}
```

1.  Un barplot per ogni clustering in cui per ogni subtype indichiamo quante persone sono in quel subtype, comparando con i risultati di iCluster.
2.  Tabelle tabelle tabelle
3.  Cluster plot mappando su 2 dimensioni (t-SNE???????)

```{r}
oldp <- par(mar=c(5.1, 8.1, 2.1, 1.1))

data <- matrix(nrow = k, ncol = length(clusterings) + 1)
for (i in 1:length(clusterings))
	data[,i] <- as.vector(table(clusterings[[i]]$clustering))
data[,length(clusterings) + 1] <- as.vector(table(labels))

barplot(data, names.arg = append(names(clusterings), "iCluster"), horiz=TRUE, las=1,
	col = c("#5D2A42", "#FB6376", "#FCB1A6"),
	main = "Patient distribution in clusters")

par(oldp)
```

```{r}
for (name in names(clusterings)) {
  print(name)
  print(as.data.frame(clusterings[[name]]$clusinfo))
}
```
```{r}
subtypes$Subtype_Integrative
```
